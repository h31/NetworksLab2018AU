# NetworksLab2017

### Elegram for Linux
#### Run server
*  **./server_linux -p *port***, where *port* - port number where we want to start server

#### Run client
*  **./client_linux -s *server_addr* -p *port* -n *nick_name***, (**order is NOT important**) where 
    * *server_addr* - address of host where server are running
    * *port* - port number where server are running
    * *nick_name* - client nick name

### Elegram for Windows
#### Run server
*  **server_windows.exe *port***, where *port* - port number where we want to start server

#### Run client
*  **server_windows.exe *server_addr* *port* *nick_name***, (**order is important**) where 
    * *server_addr* - address of host where server are running
    * *port* - port number where server are running
    * *nick_name* - client nick name

## Реализация
#### Сервер
* Для каждого очередного клиента сервер создаёт два потока, что позволяет работать одновременно с несколькими клиентами:
    * **handle_client_read** - поток, который отвечает за прием сообщений от клиента.
        * Получив очередное сообщение записываем его в общую очередь сообщений с указанием автора. 
        * Пользуемся *mutex* - ом для синхронизации с другими потоками
    * **handle_client_write** - поток, который отвечает за доставку сообщений других клиентов своему клиенту
        * Каждый клиент хранит указатель на последнее сообщение, которое он отправил клиенту из общей очереди сообщений.
        * Если в очереди нет новых сообщений, то ждем на *condition_variable*. 
        * Если есть сообщение, то сравниваем автора сообщения с нашим **nick_name**. Если равны (значит сообщение писали мы сами), то пропускаем, иначе отправляем сообщение клиенту
* За закрытие сокетов отвечают эти же потоки. Если при записи или чтении из сокета получили ошибку, то мы закрываем сокет и сообщаем другому потоку (при помощи флага в *is_closed* в *struct client*), что мы закрылись и выходим из цикла обработки запросов данного клиента. 

#### Формат сообщения
* Перед отправкой очередного сообщения клиент сначала записывает длину сообщения а потом само сообщение, что позволяет не ограничивать размер сообщений (максимальная длина = **UINT32_MAX**)

#### Клиент
* У каждого клиента, есть два потока:
    * **reader** - поток, отвечающий за вывод сообщений, прочитанных из сокета на экран
    * **writer** - поток, отвечающий за чтение сообщений из консоли и передаче их серверу через сокет.
* Для переключения между режимами чтения и записи используется глобальная переменная доступ к которой ограничен **mutex** - ом.
* При нажатии *m* мы переключаемся на режим ввода сообщений (т.е работает поток **writer**) и после нажатия *Enter* возвращаемся в режим чтения сообщений из сокета
* При подключении клиент первым делом передает свой **nick_name** серверу.
* При получении ошибки во время чтения или записи мы закрываем сокет и сообщаем другому потоку тоже завершить работу.


## Прикладной протокол
Сообщение клиента имеет следующий формат:
* Длина сообщения - 4 байта
* Содержимое сообщения (максимальная длина = **UINT32_MAX**)
Получив сообщение, сервер добавляет следующую информацию в него перед отправкой всем остальным клиентам: `<%d:%d> [%s]: %s`, где
* `<%d:%d>` - время в формате (ч:м)
* `[%s]` - имя отправителя
* `%s` - сообщение
